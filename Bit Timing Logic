
LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.numeric_std.ALL;

ENTITY my_can_btl IS
     PORT(
	     rx              : IN std_logic; 
		  tx_in           : IN std_logic;
		  transmitter     : IN std_logic;
        clk             : IN std_logic; 
	     rst             : IN std_logic;
		  reset_mode      : IN std_logic;
		  sam					: IN std_logic;
	     sjw             : IN std_logic_vector(1 DOWNTO 0);
	     brp             : IN std_logic_vector(5 DOWNTO 0);
	     prop_seg        : IN std_logic_vector(2 DOWNTO 0);
	     pseg1           : IN std_logic_vector(2 DOWNTO 0);
	     pseg2           : IN std_logic_vector(2 DOWNTO 0);
		         tx_out            : OUT std_logic;
		         clock_en          : OUT std_logic;
		         sample_point      : OUT std_logic;
					sampled_bit       : OUT std_logic;
					hard_sync         : OUT std_logic); 
					
END my_can_btl;

ARCHITECTURE behavioral OF my_can_btl IS
TYPE state IS (idle,sync,tseg1,tseg2);
SIGNAL bit_state : state;
--SIGNAL sync     : std_logic;
--SIGNAL tseg1    : std_logic;
--SIGNAL tseg2    : std_logic;
SIGNAL rx_q     : std_logic;
SIGNAL rx_edge  : std_logic;
SIGNAL clk_en   : std_logic;
SIGNAL rx_idle  : std_logic;
SIGNAL s_reg    : std_logic_vector(2 DOWNTO 0);
SIGNAL hard_sync_temp : std_logic;
SIGNAL rx_q_q : std_logic;
SIGNAL cnt : integer range 0 to 127;
SIGNAL cnt2 : integer range 0 to 20;
SIGNAL delaye: integer range 0 to 5; 
SIGNAL delayl: integer range 0 to 5;
 
BEGIN

hard_sync <= hard_sync_temp;
rx_edge <= NOT(rx_q) AND rx_q_q ;
clock_en <=clk_en;
tx_out <=tx_in or (not(transmitter));
 
PROCESS(clk)
BEGIN
IF(rising_edge(clk)) THEN
 rx_q <= rx ;
END IF;
END PROCESS;

PROCESS(clk)
BEGIN
IF(rising_edge(clk))THEN
 rx_q_q <= rx_q;
END IF;
END PROCESS;

--Hard_synchronization

 Hard_syn:PROCESS(clk,rst)
BEGIN
 IF(rst='1') THEN
  hard_sync_temp <= '0';
  rx_idle <= '1';
 ELSIF(rising_edge(clk)) THEN          
   IF(reset_mode='1') THEN
    hard_sync_temp <='0';
    rx_idle <= '1';
   ELSIF(rx_edge='1' and rx_idle ='1') THEN
    hard_sync_temp <='1';
    rx_idle <= '0';
   ELSE
    hard_sync_temp <='0';
   END IF;
 END IF;
END PROCESS Hard_syn;

--Brp clock generation

proc_brp:PROCESS(clk,rst)
 BEGIN
  IF(rst='1') THEN
   cnt        <=  0  ;
  ELSIF(rising_edge(clk)) THEN 
    IF(cnt >= 2*(to_integer(unsigned(brp)))+1) THEN
     cnt   <= 0;
    ELSIF(hard_sync_temp='1') THEN
	  cnt <= 0;
	 ELSE
     cnt   <= cnt+1;
    END IF;
  END IF;
 END PROCESS proc_brp;
 
 
 proc_brp2:PROCESS(clk)
 BEGIN
  IF(rising_edge(clk)) THEN
    IF(cnt >= 2*(to_integer(unsigned(brp)))+1) THEN
     clk_en  <= '1' ;
    ELSE
     clk_en  <= '0' ;
    END IF;
  END IF;
 END PROCESS proc_brp2;
 

 --Changing States 
  
 bit_s:PROCESS(clk,rst)
 BEGIN
  IF(rst='1') THEN
   bit_state <= idle;
	cnt2 <=0;
  ELSIF(rising_edge(clk)) THEN
     IF(hard_sync_temp='1') THEN
	   bit_state<=sync;
		cnt2<=0;
     ELSIF(clk_en='1') THEN
      CASE bit_state IS
		 WHEN tseg1 =>
		   IF(cnt2>=1+to_integer(unsigned(prop_seg))+to_integer(unsigned(pseg1))+delayl) THEN
			 cnt2<=0;
			 bit_state <=tseg2;
			ELSE
			 cnt2 <= cnt2+1;
			END IF;
		 WHEN tseg2 =>
		   IF(cnt2+delaye>=to_integer(unsigned(pseg2))) THEN
			 cnt2<=0;
			 bit_state <=sync;
			ELSE
			 cnt2 <= cnt2+1;
			END IF;
		 WHEN sync =>
		   bit_state <=tseg1;
		 WHEN OTHERS=>
		   bit_state <=idle;
			cnt2 <=0;
		 END CASE;
	 END IF;
  END IF;
  END PROCESS bit_s;
  
 --Adding or subtracting delay
  
  delay:PROCESS(clk,rst)
BEGIN
 IF(rst='1') THEN
  delaye <=0;
  delayl <=0;
 ELSIF(rising_edge(clk)) THEN
   IF(rx_edge='1') THEN
     CASE bit_state IS
      WHEN tseg2 =>
       IF(to_integer(unsigned(sjw))+cnt2>=to_integer(unsigned(pseg2))) THEN
        delaye  <= 1+to_integer(unsigned(pseg2))-cnt2;
       ELSE
        delaye  <= 1+to_integer(unsigned(sjw)) ;
       END IF;
	   WHEN tseg1 =>
       IF(to_integer(unsigned(sjw)) >=cnt2) THEN
        delayl <=1+cnt2;
       ELSE
        delayl <=1+to_integer(unsigned(sjw));
       END IF;
	   WHEN OTHERS =>
	    delayl <=0;
		 delaye <=0;
     END CASE;
   ELSIF(cnt2=0) THEN
    delaye <=0;
	 delayl <=0;
   END IF;
 END IF;
END PROCESS delay;

--Sampling

sample_t:PROCESS(clk,rst)
VARIABLE i:integer range 0 to 3 :=0;
BEGIN
 IF(rst='1') THEN 
  i:=0;
 ELSIF(rising_edge(clk)) THEN
  IF(clk_en='1') THEN
    IF(cnt2+1>=(to_integer(unsigned(prop_seg))+to_integer(unsigned(pseg1))+delayl) and bit_state=tseg1) THEN
	  s_reg(i)<=rx_q;
	   IF(i=2) THEN
		 i:=0;
		ELSE
		 i:=i+1;
		END IF;
	 END IF;
  END IF;
 END IF;
END PROCESS;

sampling:PROCESS(clk,rst)
BEGIN
 IF(rst='1') THEN
  sample_point<='0';
 ELSIF(rising_edge(clk)) THEN
   IF(clk_en='1') THEN
	    IF((cnt2=1+to_integer(unsigned(prop_seg))+to_integer(unsigned(pseg1))+delayl) and bit_state=tseg1 ) THEN
          sample_point <='1';
			  IF(sam='1') THEN
		      sampled_bit <= (((s_reg(0) and s_reg(1)) or (s_reg(1) and s_reg(2))) or (s_reg(2) and s_reg(0)));
	        ELSE
			   sampled_bit <=rx_q;
			  END IF;
	    ELSE
		  sample_point <='0';
       END IF;
   END IF;
 END IF;  
END PROCESS sampling;

END behavioral;
 
